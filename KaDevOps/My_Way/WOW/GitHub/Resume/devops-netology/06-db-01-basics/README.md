# [Домашнее задание](https://github.com/a-prokopyev-resume/virt-homeworks/tree/virt-11/06-db-01-basics) к [занятию 1. «Типы и структура СУБД»](https://netology.ru/profile/program/bd-dev-27/lessons/275710/lesson_items/1477580)[Дополнительные материалы, предложенные Нетологией](https://github.com/netology-code/virt-homeworks/tree/virt-11/additional).## Задача 1Архитектор ПО решил проконсультироваться у вас, какой тип БД лучше выбрать для хранения определённых данных.Он вам предоставил следующие типы сущностей, которые нужно будет хранить в БД:Выбор типа СУБД в зависимости от типа хранимых сущностей:- электронные чеки в json-виде:        Данные, представленные в JSON формате, удобно хранить в документных СУБД типа Mongo, но и современные СУБД типа PostgreSQL и IBM Db2 тоже поддерживают работу с JSON даже на уровне полей таких JSON структур данных.- склады и автомобильные дороги для логистической компании:     	Графовая или реляционная, потому что с помощью любой реляционной СУБД можно имитировать граф и кроме того существуют готовые надстройки над РСУБД для работы с графами данных.- генеалогические деревья:  	Если генеалогические деревья имеют вид:  https://hug.ru/upload/medialibrary/bd6/bd67ea619236fc295d6dd313c187ee83.jpg  Где не показаны сестры и братья, то достаточно и иерархической СУБД.  Если же нам нужно хранить более подробное родословное древо вида:  https://paste.pics/HFCT0  то для таких родословных древ иерархической СУБД было бы уже недостаточно, и нужна сетевая или графовая СУБД.- кэш идентификаторов клиентов с ограниченным временем жизни для движка аутентификации:     Key-value store типа Redis, Memcache и т.п.- отношения клиент-покупка для интернет-магазина:  Чтобы отразить в структуре базы данных отношения, удобнее всего использовать реляционные СУБД.## Задача 2Классификация согласно CAP-теореме распределённого высоконагруженного приложения:- данные записываются на все узлы с задержкой до часа (асинхронная запись):  Для CAP теоремы не будет свойства C из-за задержки. Асинхронность явно указывает на отсутствие консистентности данных на части узлов, т.е. система уже точно НЕ класса C. Далее действуем методом исключения, возможны варианты с A и/или P, т.е. AP или A или P. В случае PACELC это будет PA/EL (latency - задержка).- при сетевых сбоях система может разделиться на 2 раздельных кластера:  Любая распределённая система технически может быть разделена на секции при сетевом сбое (потому что абсолютно надёжных сетей не бывает, всегда есть вероятность того, что это случится на практике даже для системы, в теории отнесённой к классу CA), вопрос, как она дальше будет реагировать на запросы и насколько консистентные данные возвращать (если будет их возвращать вообще).Если после разделения система будет функционировать хотя бы частично в деградированном состоянии, то это значит такая система устойчива к разделению, т.е. имеет тип P и точно не CA. А далее в зависимости от типа деградации системы:   A) если деградирует консистентность данных С, то вероятно в лучшем случае останется хотя бы доступность A, тогда это система класса похожего на AP в терминах CAP, и PA/EL или PA/EC в терминах PACELC, для случая Else (not P, т.е. когда нет разделения) мы не знаем, как поведёт себя система, так же как из условий задачи не знаем, как она поведёт себя даже при разделении.  B)и наборот при деградации доступности A, вероятно, в лучшем случае останется хотя бы консистентность C данных системы, т.е. система класса PC терминах CAP, и PС/EL или PС/EC в терминах PACELC. Обычно базы PC при разделении оказываются в состоянии readonly, т.е. доступны для чтения, но недоступны для записи (т.е. в терминах CAP они вообще недоступны, потому что CAP под A подразумевает доступность read & write).    Т.е. единственное, что мы можем сказать о рассматриваемом случае - это только то, что система точно НЕ класса CA, если под разделением на кластеры подразумевать их хотя бы частичную работоспособность (т.е. если система выдержала такое разделение).возможны все варианты, удовлетворяющие свойству P, т.е. P или AP или CP. Для классификации по PACELC возможны варианты: PC и PA, в случае отсутствия разделения мы ничего не знаем о системе, значит возможны любые варианты, итого имеем, что возможны все четыре варианта предусмотренных PACELC теоремой: (PA/EL или PA/EC) или (PС/EL или PС/EC)- система может не прислать корректный ответ или сбросить соединение:  Отсутствует свойство A (Availability), значит, вероятно, система в лучшем случае класса CP в терминах CAP.В терминологии PACELC она точно не PA, значит, вероятно, PC, и далее для случая Else она, наверно, может быть и EC и EL?Первая пара по PACELC не может отличаться от классификации по CAP кроме случая CA.Даже если бы мы ещё не знали заранее, что система класса PC, то всё равно было бы очевидно, что система точно не класса PA потому что мы знаем, что у неё отсутствует свойство A (Availability).  Раз отсутствует свойство A, значит, в контексте CAP теоремы возможны варианты со свойствами P и/или C, PC, P, C. В контексте PACELC выбираем варианты без A, т.е. PC/EL или PC/EC.Попытался сделать сравнение свойств распределённых систем в одной таблице, где попытался наглядно совместить и сравнить особенности CAP, BASE и PACELC:https://github.com/a-prokopyev-resume/documents/blob/main/CAP_BASE_PACELC.pdf  Возможно, в таблице пока есть неточности, это пока ещё  WIP.  #### ===***=== Если у вас есть замечания по неточностям в таблице, пожалуйста, отметьте их, чтобы я мог внести исправления. ===***===Btw., я был проверяющим по этой теме на курсе B2G DevOps :)  Очень понравился ответ одного студента по задаче 2.2 (после моих наводящих вопросов): - PA/EL - высокая доступность при разделении, в противном случае высокая скорость ответа; - PC/EL - согласованность данных при разделении. В отсутствии разделения ставка на скорость ответа; - PC/EC - при разделении жертвуем доступностью в пользу консистентности. В отсутствии разделения жертвуем скоростью ответа в пользу консистентности; - PA/EC - при разделении ставка на доступность, а в отсутствии разделения - на консистентность.## Задача 3Не могут одновременно выполняться условия ACID и BASE на уже запущенной системе для одного и того же запроса, но одна и таже реализация (дистрибутив) могут поддерживать конфигурирование для той или иной модели целостности. Например, MongoDB можно настроить как для варианта ACID, так и для варианта BASE. Мало того, если верить упоминаниям в сети Интернет, даже отдельные запросы можно отправлять к СУБД с разными требованиями к целостности, отклоняясь от настроек СУБД по умолчанию. Даже асинхронная реплика РСУБД не соответствует ACID в полной мере, если будут утеряны данные на мастере, тогда и РСУБД в таком конфиге в какой-то мере имеет предрасположенность к BASE по сравнению с ACID (применительно ко всей распределённой системе, а не только к мастер узлу).## Задача 4Вам дали задачу написать системное решение, основой которого бы послужили:- фиксация некоторых значений с временем жизни,- реакция на истечение таймаута.Вы слышали о key-value-хранилище, которое имеет механизм Pub/Sub. Что это за система? Какие минусы выбора этой системы?Ответ: Redis. Его недостатки:- Несоответствие полному ACID, т.е. ближе к BASE.- Вся база должна находиться в оперативной памяти, а значит, памяти может не хватить для большой базы данных. Добавление оперативки может быть дорогим.- Снэпшоты для сохранения базы из оперативки на диск работают относительно медленно.- Нет поддержки полноценного SQL и в т.ч. поэтому не подходит для OLAP.- Однопоточная реализация, что может стать узким горлышком для производительности и масштабирования в высоконагруженной среде.Но всё же в Redis есть некое подобие журнала транзакций:https://stackoverflow.com/questions/40939756/difference-between-redis-aof-and-tarantool-wal-logИ современный Redis уже [поддерживает ACL](https://redis.io/docs/management/security/acl/)Кроме того Redis Sentinel обеспечивает кластерное решение с консенсусом.Я бы предложил ещё и СУБД Tarantool. В СУБД Tarantool решена часть проблем Redis с потреблением оперативной памяти, консистентностью данных и поддержкой относительно развитого языка запросов SQL. Кроме того, в будущем они собираются добавить совместимость с Redis на уровне wire протокола, что сделает Tarantool совместимым для многих use-cases, где пока доступен только клиент Redis.https://habr.com/ru/company/vk/blog/590375/https://en.wikipedia.org/wiki/Tarantoolhttps://github.com/centrifugal/rotorИнтересные статьи по темам CAP (критика в т.ч.) и PACELC:     * https://ru.wikipedia.org/wiki/Теорема_CAP * https://robertgreiner.com/cap-theorem-revisited/ * https://habr.com/ru/post/258145/ * https://habr.com/ru/post/328792/ * https://bigdataschool.ru/blog/cap-alternatives-for-nosql-and-big-data.html * https://en.wikipedia.org/wiki/PACELC_theorem