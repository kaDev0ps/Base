Чтобы это исправить надо добавить себя в группу docker и перелогиниться. Примерно вот так:

`sudo usermod -a -G docker  user1`


Все команды можно посмотреть в документации

docs.docker.com

Я приведу в пример те команды, которые будут использоваться в этом курсе:



run - уже знакомая команда. она создает и запускает контейнер

pull - команда закачивает образ из репозитория на наш компьютер. run вызывает эту функцию, если контейнер не скачан.

ps - просмотр запущенных контейнеров

rm - удаление контейнера. Не образа, а именно контейнера

stop - остановить запущенный контейнер

start - запустить остановленный контейнер

exec - выполнить команду в запущенном контейнере

cp - копирование файлов между контейнером и хост-системой.

info - информация о состоянии и конфигурации контейнера

logs - логи контейнера

attach - зацепиться в консоль контейнера

search - поиск образа в репозитории
#
Так. Для очередной практики осталось попробовать стопнуть конейнер

`docker stop container_id`

И теперь ты умеешь все, что требуется для следующей части практики. Ты умеешь запускать, останавливать и чистить контейнеры. Возможно ты уже испытал команду attach. Если нет, то попробуй запустить опять наш контейнер в фоне, а потом выполнить

`docker attach container_id`

Круто, правда? Ты подключился к консоли контейнера. Правда если нажать exit, то bash завершит свою работу и контейнер остановится. А вот если окно с консолью на крестик закрыть, то не завершится.

Теперь запустим что-то полезное. Например mysql.

# Поиск образов
docker search mysql
# Загружаем
docker pull mysql
# Запускаем
docker run -it mysql

--name - Имя контейнера. Чтобы видеть его в списке других

-e - Этим флагом передаются переменные при запуске контейнера. Сокращенно от environment

-P - этот флаг отвечает за проброс порта из контейнера на хост-машину. В верхнем регистре этот флаг дает проброс портов на случайные порты хост-машины. В нижнем регистре можно указать с какого порта, на какой порт пробросить. Примерно так:   -p 2222:22

Сначала порт на хост-машине. Потом порт в контейнере.

# Итак. Запускаем контейнер.

`docker run --name Project1.MySQL -e MYSQL_ROOT_PASSWORD=vecrek -P -d mysql`

Итак, что же мы делаем:

1. Выдаем контейнеру имя Project1.MySQL

2. Задаем рутовый пароль на mysql

3. Заказываем проброс на рандомный порт.

Итак. Мы задали контейнеру имя. Только ли оно для красоты?

Остановка и запуск по имени
`docker stop Project1.MySQL`

`docker start Project1.MySQL`
Просмотр открытых портов
`docker port Project1.MySQL`
Тут мы видим параметры проброса портов с виртуалки на хост-машину. Обрати внимание на адрес 0.0.0.0. Это значит, что на этот порт светится на хост-машине на всех сетевых интерфейсах и принимает запросы от всех желающих.

`docker logs Project1.MySQL`

Тут логи контейнера. Обычно сюда выводят логи только основного приложения. Очень полезно для диагностики. А также если бы мы выбрали генерировать пароль для mysql автоматически, то он бы прописался именно в этом логе

`docker inspect Project1.MySQL`

Эта команда выведет подробную конфигурацию запущенного контейнера. Тут можно увидеть все. И скрипт по умолчанию и настройки сети и имя образа, из которого контейнер создан.

Но вернемся к практике. Вот запущен контейнер. Вот есть порты, на которые можно подключиться и зайти в MySQL. Попробуй =).

`mysql -u root -pvecrek -P 32777 -h  localhost`

Попробуем решить проблему. Подключаемся к консоли в интерактивном режиме и выполняем подключение к базе:

`docker exec -it Project1.MySQL  mysql -u root -pvecrek`

А уже оттуда можно выполнить следующий запрос:

`set password for 'root'@'%' = 'vecrek';`

`flush privileges;`

`exit;`

Все. Теперь подключается.

#
Одно смущает. Раз инстанс пока один, то почему бы не занять стандартный порт?

Делай раз:

`docker stop Project1.MySQL`

`docker rm $(docker ps -a -q -f status=exited)`

Делай два:

`docker run --name Project1.MySQL -e MYSQL_ROOT_PASSWORD=vecrek -p 3306:3306 -d mysql`

Обрати внимание. Для нерандомных портов флаг -p в нижнем регистре. 

Продолжаем исследование контейнера. Заходи в mysql и создай там базу. Можешь даже дамп какой-то загрузить.

`docker exec -it Project1.MySQL bash`

`mysql -u root -pvecrek  -h localhost --protocol=tcp`

`create database test1;`

`exit;`

Теперь создай в корне файловой системы контейнера какой-нибудь файл.

`docker exec -it Project1.2ySQL touch /etc/muhaha.txt`

`docker exec -it Project1.2ySQL ls /etc`

Файлик созданный видно? Хорошо. А теперь останови контейнер и запусти заново.

`docker stop Project1.2ySQL`

`docker start Project1.MySQL`
А теперь проверь созданный файлик:

`docker exec -it Project1.MySQL ls /etc`

И зайди в mysql проверь сохранилась ли база test1

`show databases;`

Это я все к чему. Вот когда ты создаешь каждый раз новый контейнер через run, то изменения не сохраняются. Но в рамках одного контейнера изменения сохраняются. Каждый старт-стоп добавляет к диску новый слой. Только и всего.
#
C mysql закончили. Следующим приложением, которое мы будем запихивать в контейнер, будет nginx.

На примере веб-сервера я покажу как делать общую папку между хост-машиной и контейнером.

`docker pull nginx`
`docker run -d -p 8000:8080 nginx`
И если подключиться теперь к нашему новоиспеченному веб-серверу, то увидим страницу приветствия nginx

Попробуем поднять свою страничку. Страничка будет в формате html, т.к. интерпретатора php в контейнере нет.

Для начала надо подготовить папку. Как оказалось в образе нет папки /var/www

`docker exec -it web mkdir /var/www`

`docker exec -it web chown nginx:nginx /var/www`

Скачиваем файл   index.html

`wget http://distrib.yodo.me/docker-index.html -O index.html`

И закидываем файл в контейнер

`docker cp index.html web2:/var/www/index.html`
Сам мини-сайтик готов. Теперь надо добавить конфиг нашего сайта вот такого содержания:

server {
server_name test2.ru;
access_log /var/log/nginx_access.log;
error_log /var/log/nginx_error.log;
listen 80;
root /var/www/;
index index.html index.htm;
location / {
try_files $uri $uri/ =404;
}
}

<!-- 
server {

    server_name test.ru;

    access_log /var/log/nginx_access.log;

    error_log /var/log/nginx_error.log;

    root /var/www;

    location / {

                index  index.html index.htm index.php;

    }

} -->
И добавить его в контейнер:

`docker cp test.conf web:/etc/nginx/conf.d/`

Теперь надо перезапустить nginx для того, чтобы применить изменения. 

Это делается через stop и start контейнера.

Не веришь? Ну попробуй выполнить:

`docker exec -it web  service nginx restart`

Упал контейнер? А я предупреждал. 

`docker start web`

Сайт у нас называется test.ru. Но ведь в днс нет записи о таком имени. И чтобы попасть на этот тестовый сайт, надо отредактировать файл hosts

Для linux это /etc/hosts

Для windows это C:\Windows\System32\drivers\etc

IP-адрес виртуалки, на которой я играюсь с докером - 192.168.88.61. Тебе нужно указать адрес своей виртуалки.

В hosts нужно вписать следующую строку:

172.21.0.14     test.ru

А теперь заходи на http://test.ru

# Соберем контейнер nginx, в котором уже будет внедрен конфигурационный файл и наш мини-сайтик.

Сборка образа делается командой build из конфигурационного файла в специальном формате. Конфигурационный файл должен называться Dockerfile. При запуске docker build ищется именно этот файл.

Сейчас будет немного теории. Я расскажу про команды, которые могут применяться в Dockerfile. А потом по шагам мы соберем свой образ.
Например: 

`FROM ubuntu`

Дальше порядок действий не так важен.

`EXPOSE`

Этим параметром мы публикуем рабочие порты контейнера. Естественно только те, к которым разрешается подлючаться извне. Протокол может быть и tcp (по умолчанию) и udp.

# Публикуем tcp-порт:

`EXPOSE 8888`

# Публикуем udp-порт

`EXPOSE 8888/udp`
# COPY

Этим параметром добавляют файлы (или папки) в контейнер. К примеру файлы конфигурации.

Сначала указывается файл, который надо скопировать. А после путь, куда внутри контейнера его надо закинуть.

Если файл в контейнере существовал, то он будет заменен.

`COPY ./test.conf  /etc/nginx/conf.d`

# ADD

Делает то же самое что и COPY. А зачем тогда есть две эти команды?

# COPY 
копирует только локальные файлы. Они должны быть на том же компьютере где собирается образ.

А вот ADD может скачивать файлы и если это архив, то он будет распакован в путь назначения. Отказаться от распаковки нельзя.

Например:

`ADD http://mysite.ru/downloads/achive.tar.gz  /opt/`

Поддерживаются не все форматы архивов.  Точно поддерживаются tar,gz,bz2,xz.
RUN

Этот параметр запускает указанную команду внутри образа во время сборки. К примеру мы можем сделать что-то вроде

`RUN apt-get update && apt-get install -y nginx`

Каждая запись RUN создает новый слой файловой системы. Следующие за ней параметры Dockerfile  выполняются с учетом ее результатов.

Поэтому хорошей практикой считается запихнуть как можно больше команд в одну инструкцию RUN. Dockerfile получается не таким красивым и понятным, но зато образ будет собран оптимальнее.

# CMD

Основное ее назначение это запуск скрипта или приложения по умолчанию.

Если написать несколько таких инструкций, то выполнится последняя.

Применяется как-то так:

`CMD ["python", "./app.py"]`

`CMD ["bash", "/opt/systeminit.sh"]`
# VOLUME

Через эту команду можно настраивать проброс папки из хост-системы в контейнер.

Правда тут нельзя указать конкретный путь в хост-системе. Папка будет проброшена в /var/lib/docker/volumes.

Чтобы увидеть точный путь, надо посмотреть раздел Mounts в выводе docker inspect 

Между тем, с помощью флага -v при запуске контейнера можно настроить четкое соответствие между папкой в контейнере и папкой на хост-системе. А при сборке контейнера видимо посчитали, что такая возможность будет приводить к ошибкам.
# Создание образа
Я надеюсь ты еще не удалил файлы index.html и test.conf. Сейчас они нам пригодятся.

Для начала предлагаю создать папку dockertest, где и будем мусорить. В нее переносим наши уже имеющиеся файлы и переходим вслед за ними:
<!-- 
mkdir dockertest

mv index.html dockertest/

mv test.conf dockertest/

cd dockertest -->

# Dockerfile
Следующим шагом требуется создать файл с названием Dockerfile.

Содержание у него будет вот такое:
<!-- 
FROM nginx

RUN  mkdir /var/www

COPY test.conf  /etc/nginx/conf.d/

COPY index.html   /var/www/ -->

Теперь нужно собрать образ. Для этого надо выполнить вот такую команду:

`docker build -t user1/nginxtest .`

user1/nginxtest это имя контейнера. Принято называть его в таком формате. Сначала идет ник создателя, а через слеш название образа.

Прошу обратить внимание на точку в конце. Она указывает где искать Dockerfile. Т.к. мы с ним в одной директории, то указываем точку.
Собралось? Теперь туши и удаляй контейнер под именем web, который мы чуть раньше мучали.


Время поднимать наш свежий:

`docker run --name web -p 8001:80 -d user1/nginxtest`



И пробуй открыть http://test.ru.   Намного меньше действий, а результат тот же. Правда здорово? 

Делиться своими образами можно через docker hub. Это публичный репозиторий.

Для этого нужно зарегистрироваться на сайте https://docker.io

После того как зарегистрируешься, заходи на машину с докером и делай так:

`docker login`

у тебя спросят логин и пароль. Вводишь те, которые указал при регистрации на сайте.

Если все прошло успешно, то можешь выгрузить свой образ вот такой командой:

`docker push user1/nginxtest`

Все. Теперь этот образ можно запустить с любого компьютера. После выполнения docker run user1/nginxtest  этот образ будет скачан из публичного репозитория и запущен. Можно делиться образом с друзьями и коллегами.
#
Уже хорошо. Однако вот это вот упаковывание целого сайта в образ...  ну не будешь же ты при каждом косметическом измении новый образ собирать. Можно конечно, но зачем?

Намного удобнее пробросить папку /var/www в хост-машину и вносить изменения на сайте простым копированием (а то и вовсе править прямо наживую, если это dev-хост).
#
Первый вариант. Использование VOLUME в Dockerfile.

Открывай Dockerfile и приводи его к такому виду:
<!-- 
FROM nginx

RUN  mkdir /var/www

COPY test.conf  /etc/nginx/conf.d/

VOLUME /var/www -->


Теперь пересобираем образ (не забыл как?)

`docker build -t user1/nginxtest .`

После сборки образа удаляй имеющийся контейнер web и запускай новую сборку
`docker run --name web -p 8002:80 -d user1/nginxtest`

Нет. Контейнер не сломан. Просто папка /var/www пуста.

Сейчас я расскажу как ее заполнить. В контейнер мы больше лезть не будем. Он теперь будет как неизменяемая сущность. А сайт теперь управляется локально.

Вводи 

`docker inspect web`

и ищи секцию Mounts

Как видно на картинке - путь к общей папке в хост-системе будет вот такой:  /var/lib/docker/volumes/878238b26e2327afaf336afecce9f6b43a883330e768a86bc1054ac47f3aad02/_data

Эта папка принадлежит пользователю root, поэтому работать с ней придется через sudo.

Копируем наш мини-сайт:

`sudo cp index.html /var/lib/docker/volumes/edf68dcb62ac1d6296e797de8ec54d96c368d059899d2ae0529f505ffe54b716/_data`
ак намного проще вести разработку. Контейнер собран один раз и запущен один раз и больше никакой суеты.

При этом если сайт сохранять в облачный репозиторий git, то развернуть место разработчика на новом компьютере будет занимать две команды:

- запустить образ

- скачать сайт из репозитория.
#
То же самое можно сделать не пересобирая образ, а задав параметры при запуске контейнера. Для этого есть флаг -v

Причем тут есть два варианта.

Первый вариант - монтируем папку из хост-системы напрямую в контейнер.

Второй вариант это создавать диск через команду docker volume, а потом при старте контейнера монтировать именно этот диск.
#
Создавай папку ~/dockertest/www

`mkdir ~/dockertest/www`

И создай файл ~/dockertest/www/index.html следующего содержания:

`nano /dockertest/www/index.html`

https://pastebin.com/ft5tXNiJ

# Теперь монтируем эту папку в контейнер как /var/www

`docker run --name web7 -p 8007:80 -v ~/VS_code/Base/KaDevOps/YoDo/Docker/dockertest/www:/var/www -d user1/nginxtest`

Как только контейнер запустился, можно зайти на http://test.ru и убедиться, что все работает.

При этом права на папку остались те же. Т.е. работать с файлами можно и без sudo. Что удобно.

#
Теперь второй способ.
Он вообще больше предназначен не для связи хост-машины и одного контейнера, а для создания общего ресурса между контейнерами (ну и хост-машиной, раз уж на то пошло).
Для работы с volume у докера есть целый ряд команд.
Для начала посмотри список имеющихся volume.

`docker volume ls`

Как видишь каждый раз при каждом запуске контейнера с инструкцией volume при сборке, общая папка создается и не удаляется при удалении контейнера. Это на случай если данные оттуда еще понадобятся.

Удалить ненужные volume можно принудительно, с помощью

`docker volume rm`

Преимущество создания volume через эти команды в том, что можно не только папочки на хост-машине линковать, но также сетевую папку, раздел на диске или ram-диск (tmpfs).
#
Итак. Делаем общий volume.

`docker volume create --name test-website`

Теперь посмотри список volume-ов

`docker volume ls`

Там должен быть тот, что мы только создали. Только называется осознанно, а не как огромное шестнадцатиричное число.

Можно рассмотреть его через 
`docker volume inspect test-website`

Новый файл (/var/lib/docker/volumes/test-website/_data/index.html) должен иметь следующее содержимое:
<!-- 
<html>
<head>
  <title>Умопомрачительно тестовая страница</title>
  <meta charset="utf-8">
</head>
<body>
<h1> Тест Volume. Вариант #41 </h1>
</body>
</html> -->

А теперь уже традиционно тушим контейнер web, удаляем его и собираем заново с новыми параметрами. Наверное надоело уже вводить пачку команд для пересборки контейнера? Попробуй потушить контейнер, а потом сразу выполнить вот эту команду.

`docker run --rm --name web -p 8008:80 -v test-website:/var/www -d user1/nginxtest`



Флаг --rm приказывает докеру самостоятельно разобрать контейнер, если он упал или был остановлен. 

Все работает. Теперь ты умеешь пользоваться volume-ами и обмениваться файлами между хост-машиной и контейнером.


# Пришло время разбавить наш комплект контейнеров еще одним - php-fpm.

Мы с тобой шаг за шагом создадим связку **Nginx + php-fpm + MySQL**

По хорошему Nginx + php-fpm удобно было бы совместить в одном контейнере. Однако озвученная мной конфигурация позволит раскрыть тебе еще несколько аспектов работы с докером.

#
